-# game/show.html.haml
-#
-# This version asynchronously requests moves from the server after rendering the latest move.
-# 
-# begin hideaous workaround for JQTouch and HAML: It seems that <div style='current' id='foo'> is treated differently than
-# <div id=';foo' style='current>, and HAML generates one form when you write .current{ :id=>'foo } and the other when you
-# write %div{ :style=>'current', :id=>'foo' }
-last = @game.actions.last
-# TODO: implement wipes for history
-# NOTE: loading the latest moves should be divorced from setting whether the current move is playable
:javascript
  var game_show = function () {
    var update_latest_server_info = null;
    var current_latest_move = #{last.nil? ? 0 : last.cardinality};
    var latest_server_info = #{@info.to_json};
    var move_selector = function (move_number) {
      return '#m' + move_number;
    };
    var place_stone = function (click_event_data) {
      var position = this.getAttribute('id');
      $.ajax({
        url: '#{create_move_url(:game_id=>@game.id, :position=>'zzzzz')}'.replace('zzzzz', position),
        type: 'POST',
        dataType: 'json',
        success: update_latest_server_info,
        error: function (error_response) {
          GO.message('error', 'unable to place a stone at ' + position + ' because: ' + error_response.responseText);
        },
      });
    };
    var update_active_div = function (move_number) {
      if (move_number) {
        var selector = move_selector(move_number) + ' .board .empty'
        $('.active_move').not(selector).unbind('click.place_stone').css({
          'cursor': 'default'
        }).removeClass('active_move');
        $(selector).not('.active_move').bind('click.place_stone',
          place_stone
        ).css({
          'cursor': 'pointer'
        }).addClass('active_move');
      }
      else {
        $('.active_move').unbind('click.place_stone').css({
          'cursor': 'default'
        }).removeClass('active_move');
      }
    };
    var get_latest_moves = function (callback) {
      $.ajax({
        url: '#{get_updates_url(:game_id=>@game.id, :after_move=>'zzzzz', :layout=>'false')}'.replace('zzzzz', current_latest_move),
        type: 'GET',
        dataType: 'html',
        success: function (html) {
          update_moves = $(html);
          if (update_moves.size() > 0) {
            update_moves.insertAfter('#m' + current_latest_move);
            $(move_selector(current_latest_move) + ' .history .next').removeClass('invisible');
            current_latest_move = current_latest_move + update_moves.size();
            if (callback) {
              callback(move_selector(current_latest_move));
            }
          }
        },
        error: function (error_response) {
          GO.message('error', 'unable to load the game history after ' + current_latest_move + ' because: ' + error_response.responseText);
        }
      });
    };
    var process_server_info = function () {
      var can_process_server_info = true;
      return function () {
        if (!can_process_server_info || !latest_server_info.move_number) {
          return null;
        }
        can_process_server_info = false;
        if (latest_server_info.move_number > current_latest_move) {
          var was_current_latest_move = current_latest_move;
          if (latest_server_info.active) {
            get_latest_moves(function (latest_move_selector) {
              update_active_div(latest_server_info.move_number);
              update_status_on_current_board();
              can_process_server_info = true;
              if ($(move_selector(was_current_latest_move)).is('.current')) {
                jQT.goTo(latest_move_selector, 'flip');
              }
            });
          }
          else {
            get_latest_moves(function (latest_move_selector) {
              update_active_div();
              update_status_on_current_board();
              can_process_server_info = true;
              if ($(move_selector(was_current_latest_move)).is('.current')) {
                jQT.goTo(latest_move_selector, 'flip');
              }
            });
          }
        }
        else {
          update_active_on_current_board();
          can_process_server_info = true;
        }
      }
    }();
    var get_history_up_to = function (current_latest_move) {
      $.ajax({
        url: '#{get_history_url(:game_id=>@game.id, :before_move=>'zzzzz', :layout=>'false')}'.replace('zzzzz', current_latest_move),
        type: 'GET',
        dataType: 'html',
        success: function (html) {
          $(html).insertAfter('#m0');
          $(move_selector(current_latest_move) + ' .history .prev').removeClass('invisible');
        },
        error: function (error_response) {
          GO.message('error', 'unable to load the game history before ' + current_latest_move + ' because: ' + error_response.responseText);
        }
      });
    };
    var update_latest_server_info = function () {
      $.ajax({
        url: '#{move_info_url(:game_id=>@game.id)}',
        type: 'GET',
        dataType: 'json',
        success: function (info) {
          latest_server_info = info;
        }
      });
    };
    var update_active_on_current_board = function () {
      if (latest_server_info.active) {
        update_active_div(current_latest_move);
      }
      else {
        update_active_div();
      }
    };
    var update_status_on_current_board = function () {
      var selector = move_selector(current_latest_move);
      $('.move .status').not(selector).addClass('invisible');
      $(selector + ' .status').text('this is the current board');
    };
    return {
      update_status_on_current_board: update_status_on_current_board,
      update_active_on_current_board: update_active_on_current_board,
      process_server_info: process_server_info,
      get_history_up_to: get_history_up_to,
      update_latest_server_info: update_latest_server_info
    };
  }();
#settings
  -# list all game settings
:javascript
  document.title = '#{self.current_user ? self.current_user.email : 'guest'}';
  $(document).ready( function () {
    game_show.update_active_on_current_board();
    game_show.update_status_on_current_board();
    $.PeriodicalUpdater('#{move_info_url(:game_id=>@game.id)}',
      { type : 'json', minTimeout: 2000, maxTimeout: 8000 },
      game_show.update_latest_server_info
    );
    $(document).everyTime('1s', function (count) {
      game_show.process_server_info();
    });
  });
-if last.nil?
  .current.move#m0
    .toolbar 
      %h1 Beginning
      %a.back{:href=>"#"} Back
    .board
      = render :partial => "board/board", :locals => { :board => @game.initial_board }
    .status
    %ul.individual.history
      %li.prev.invisible
        %a.slideback{:href=>"#m0"}
          Prev
          %small 0
      %li.next.invisible
        %a{:href=>"#m1"}
          Next
          %small 1
-else
  :javascript
    $(document).ready( function () {  
      game_show.get_history_up_to(#{last.cardinality});
    });
  .move#m0
    .toolbar 
      %h1 Beginning
      %a.back{:href=>"#"} Back
    .board
      = render :partial => "board/board", :locals => { :board => @game.initial_board }
    .status
    %ul.individual.history
      %li.prev.invisible
        %a.slideback{:href=>"#m0"}
          Prev
          %small 0
      %li.next
        %a{:href=>"#m1"}
          Next
          %small 1
  .current.move{:id=>"m#{last.cardinality}"}
    .toolbar 
      %h1 Move #{last.cardinality}
      %a.back{:href=>"#"} Back
    .board
      = render :partial => "board/board", :locals => { :board => last.after }
    .status
    %ul.individual.history
      %li.prev.invisible
        %a.slideback{:href=>"#m#{last.cardinality - 1}"}
          Prev
          %small
            = last.cardinality - 1
      %li.next.invisible
        %a{:href=>"#m#{last.cardinality + 1}"}
          Next
          %small
            = last.cardinality + 1