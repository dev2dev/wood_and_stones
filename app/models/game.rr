class Game < ActiveRecord::Base
  
  class InvalidInitialization < Exception; end
  
  belongs_to :current_board, :class_name => "Board", :foreign_key => "current_board_id"
  
  validates_presence_of :current_board
  validates_associated :current_board
  
  belongs_to :black, :class_name => "User", :foreign_key => "black_id"
  validates_presence_of :black
  
  belongs_to :white, :class_name => "User", :foreign_key => "white_id"
  validates_presence_of :white
  
  has_many :actions, :class_name => "Action::Base", :foreign_key => "game_id"
  has_many :boards, :through => :actions, :source => :after
  
  OPTIONS = [:handicap, :dimension, :fork]
  
  def initialize(attributes)
    attributes ||= Hash.new
    options = OPTIONS.inject(Hash.new) do |h, attr|
      (h[attr] = attributes[attr]) and attributes.delete(attr)
      h
    end
    super(attributes)
    if forked = options[:fork]
      self.current_board = if forked.kind_of?(Board)
        forked
      elsif forked.respond_to?(:current_board)
        forked.current_board
      else
        raise Game::InvalidInitialization.new("Don't know what to do with a #{it.inspect}")
      end
      fork
    elsif dimension = options[:dimension]
      self.current_board = Board.create(:dimension => dimension)
      options[:handicap].to_i.into do |handicap| # nil.to_i == 0!
        if handicap > 1
          self.current_board.handicap(handicap)
          self.current_board.save!
          self.to_play = Board::WHITE_S
        else
          self.to_play = Board::BLACK_S
        end
      end 
      start
    else 
      raise Game::InvalidInitialization.new("cannot initialize a game without forking or setting a dimension")
    end
  end
  
  state_machine do
    
    event :start do
      transition :to => :started
    end
    
    event :fork do
      transition :to => :forked
    end
    
    event :move do
      transition :from => [:started, :moved], :to => :moved
    end
    
    event :end do
      transition :from => [:started, :moved], :to => :ended
    end
    
  end
  
end