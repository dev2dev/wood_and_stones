class Game < ActiveRecord::Base
  
  class InvalidInitialization < Exception; end
  
  belongs_to :current_board, :class_name => "Board", :foreign_key => "current_board_id"
  
  validates_presence_of :current_board
  
  belongs_to :black, :class_name => "User", :foreign_key => "black_id"
  validates_presence_of :black
  validates_associated :black
  
  belongs_to :white, :class_name => "User", :foreign_key => "white_id"
  validates_presence_of :white
  validates_associated :white
  
  has_many :actions, :class_name => "Action::Base", :foreign_key => "game_id", :order => :cardinality
  has_many :boards, :through => :actions, :source => :after
  
  has_many :secrets, :as => :target
  
  OPTIONS = [:handicap, :dimension, :fork, :b, :w]
  
  named_scope :played_by, lambda { |user|
    {:conditions => ["black_id = ? OR white_id = ?", user.id, user.id]}
  }
  
  composed_of :initial_board, :class_name => "Board", :mapping => [%w(initial_board_serialized as_str), %w(dimension dimension)]
  composed_of :current_board, :class_name => "Board", :mapping => [%w(current_board_serialized as_str), %w(dimension dimension)]
  
  validates_each :initial_board, :current_board do |record, attribute, value|
    Board.validate_for(record, attribute)
  end
  
  def user_to_play
    self.to_play.andand { self.send(it) } unless self.ended?
  end
  
  def user_to_play_id
    self.to_play.andand { |colour| self.send("#{colour}_id") } unless self.ended?
  end
  
  def initialize(attributes)
    attributes ||= Hash.new
    options = OPTIONS.inject(Hash.new) do |h, attr|
      (h[attr] = attributes[attr]) and attributes.delete(attr)
      h
    end
    super(attributes)
    if black_email = options[:b]
      self.black ||= User.find_or_create_by_email(black_email)
    end
    if white_email = options[:w]
      self.white ||= User.find_or_create_by_email(white_email)
    end
    if forked = options[:fork]
      self.current_board = if forked.kind_of?(Board)
        forked
      elsif forked.respond_to?(:current_board)
        forked.current_board
      else
        self.errors.add :before, "cannot initialize a game without forking or setting a dimension"
      end
      fork
    elsif dimension = options[:dimension]
      board =  Board.new(nil, dimension)
      options[:handicap].to_i.into do # nil.to_i == 0!
        if it > 1
          board.handicap(it)
          self.to_play = Board::WHITE_S
        else
          self.to_play = Board::BLACK_S
        end
      end 
      self.initial_board, self.current_board = board, board
      start
    else 
      self.errors.add :before, "cannot initialize a game without forking or setting a dimension"
    end
  end
  
  def current_removed
    self.current_removed_serialized.andand { eval(it) } or []
  end
  
  def current_removed=(stones)
    self.current_removed_serialized = stones.inspect
  end
  
  def valid_positions
    return [] if self.ended?
    returning( self.current_board.legal_moves_for(self.to_play) ) do |valid_move_hashes|
      if self.current_removed.size == 1  # last play removed one stone
        valid_move_hashes.reject! { 
          its.location.to_a == self.current_removed.first.to_a and # replay the removed stone
          its.dead_stones.size == 1 # removes one stone. i think this is a sufficient condition
        }
      end
    end.map(&:location)
  end
  
  state_machine do
    
    event :start do
      transition( nil => :started )
    end
    
    event :fork do
      transition( all => :forked )
    end
    
    event :move do
      transition( (all - [:ended]) => :moved )
    end
    
    event :pass do
      transition( (all - [:ended, :passed]) => :passed, :passed => :ended )
    end
    
    event :resign do
      transition( all => :ended )
    end
    
  end
  
end