class Board
  
  attr_accessor :as_str
  attr_accessor :dimension
  
  DIMENSIONS = [9, 11, 13, 15, 17, 19]
  
  BLACK_S, WHITE_S = 'black', 'white'
  
  class Occupied < Exception; end
  
  class Wtf < Exception; end
  
  # intended for an array of two elements, one of which is an array of black things
  # and the other is an array of white things
  module BlacksAndWhites
    
    def self.for(*arr)
      returning(arr) do
        arr.extend(self)
      end
    end
    
    def blacks
      self.first
    end
    
    def whites
      self.last
    end
    
    def all
      self.first + self.last
    end
    
    def map
      BlacksAndWhites.for(yield(blacks), yield(whites))
    end
    
  end
  
  # intended to extend an array of two offsets across and down
  module Location
    
    attr_accessor :board
    
    def self.for(board, across, down)
      returning([across, down]) do
        it.extend(self)
        it.board = board
      end
    end
    
    def across
      self.first
    end
    
    def down
      self.last
    end
    
    def open?
      self.board.to_a[self.across][self.down].blank?
    end
    
    def black?
      self.has?(BLACK_S)
    end
    
    def white?
      self.has?(WHITE_S)
    end
    
    def has?(colour)
      self.board.to_a[self.across][self.down] == colour
    end
    
    def have(colour)
      arr = self.board.to_a
      arr[self.across][self.down] = colour
      self.board.as_str = arr.inspect
      self
    end
    
    def blacken
      self.have(BLACK_S)
    end
    
    def whiten
      self.have(WHITE_S)
    end
    
    def remove
      arr = self.board.to_a
      arr[self.across][self.down] = nil
      self.board.as_str = arr.inspect
      self
    end
  
    def adjacent_scalars(offset)
      if offset == 0
        [offset + 1]
      elsif offset == (board.dimension - 1)
        [offset - 1]
      else
        [offset + 1, offset - 1]
      end
    end
  
    def adjacent_locations
      self.adjacent_scalars(self.across).map { Location.for(board, it, self.down) } + 
      self.adjacent_scalars(self.down).map { Location.for(board, self.across, it) }
    end
  
    def liberties
      self.adjacent_locations.select{ its.open? }
    end
    
    def has_liberty?
      !self.liberties.empty?
    end
    
    def left_edge?
      self.across == 0
    end
    
    def right_edge?
      self.across == (self.board.dimension - 1)
    end
    
    def center?
      !self.left_edge? && !self.right_edge?
    end
    
    def top_edge?
      self.down == 0
    end
    
    def bottom_edge?
      self.down == (self.board.dimension - 1)
    end
    
    def middle?
      !self.top_edge? && !self.bottom_edge?
    end
    
    def hoshi?
      self.board.hoshi_points.include?(self)
    end
    
    def to_s
      (LETTERS[self.across] + LETTERS[self.down]).downcase
    end
    
  end

  # intended to extend arrays of locations
  module Grouping
  
    # def valid?
    #   black_groupings, white_groupings = self.class.groupings(@board, @offsets)
    #   both_groupings = black_groupings + white_groupings
    #   both_groupings.size == 1 && both_groupings.first.size == @offsets.size
    # end
    
    attr_accessor :board
    
    def self.for(board, *locations)
      returning(locations) do
        it.extend(self)
        it.board = board
      end
    end
    
    def self.groupings_for_one_colour(board, stones)
      stones.inject([]) do |groupings_so_far, stone|
        raise "I screwed this up" unless stone.kind_of?(Location)
        groupings_adjacent_to_this_stone = stone.adjacent_locations.map { |adjacent_location|
          groupings_so_far.detect { it.include?(adjacent_location) }
        }.compact
        if groupings_adjacent_to_this_stone.size == 0
          # create a new grouping
          groupings_so_far << self.for( board, stone )
        elsif groupings_adjacent_to_this_stone.size == 1
          # add this stone to the grouping
          groupings_adjacent_to_this_stone.first << stone 
        else
          # merge groupings
          groupings_so_far = groupings_so_far - 
              groupings_adjacent_to_this_stone + 
              [
                self.for(
                  board,
                  *(groupings_adjacent_to_this_stone.inject(&:+) + [stone])
                )
              ]
        end
        groupings_so_far
      end
    end
    
    def liberties
      self.map { its.liberties }.inject([], &:+)
    end
    
    def alive?
      self.any? { it.has_liberty? } 
    end
    
    def dead?
      !self.alive?
    end
  
  end
  
  class Column
    
    attr_accessor :board
    attr_accessor :across
    
    def initialize(board, across)
      self.board = board
      self.across = across
    end
    
    def [](down)
      Location.for(board, self.across, down)
    end
    
    def []=(down, value)
      returning(Location.for(board, self.across, down)) do |location|
        if value.nil?
          location.remove
        elsif value == WHITE_S || value == BLACK_S
          location.have(value)
        else
          raise Wtf.new("WTF is a #{value.inspect}?")
        end
      end
    end
      
    
  end
  
  def initialize(str, dimension)
    self.as_str = str
    self.dimension = dimension
    initialize_as_str
  end
  
  def self.validate_for(belongs_to, *board_attrs)
    board_attrs.each do |sym|
      board = belongs_to.send(sym)
      undead = board.dead_stones.all
      belongs_to.errors.add(sym, "The stones at #{undead.to_sentence} are dead") unless undead.empty?
      belongs_to.errors.add(sym, "#{board.dimension} is not a valid board size") unless DIMENSIONS.include?(board.dimension)
    end
  end
  
  STARS = Board::DIMENSIONS.inject(Hash.new) do |sizes_to_game_sets, dimension|
    sizes_to_game_sets.merge(
      dimension => begin
        offset = if dimension <= 11
            3
          else
            4
          end
        top = left = offset - 1
        middle = dimension / 2
        bottom = right = dimension - offset
        {
          2 => [[left, bottom], [right, top]],
          3 => [[left, bottom], [right, top], [right, bottom]],
          4 => [[left, bottom], [right, top], [right, bottom], [left, top]],
          5 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [middle, middle]],
          6 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [left, middle], [right, middle]],
          7 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [left, middle], [right, middle], [middle, middle]],
          8 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [left, middle], [right, middle], [middle, top], [middle, bottom]],
          9 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [left, middle], [right, middle], [middle, top], [middle, bottom],
                [middle, middle]]
        }
      end
    )
  end
  
  HOSHI = Board::DIMENSIONS.inject(Hash.new) do |board_size_to_number_of_hoshi, dimension|
    board_size_to_number_of_hoshi.merge(
      if dimension < 13
        {dimension => 4}
      elsif dimension < 17
        {dimension => 5}
      else
        {dimension => 9}
      end
    ) 
  end
  
  def star_points(number_of_stones)
    STARS[self.dimension][number_of_stones]
  end
  
  def hoshi_points()
    @hoshi_points ||= self.star_points(HOSHI[self.dimension])
  end
  
  def handicap(number_of_stones)
    self.star_points(number_of_stones).each do |across, down|
      self[across][down].blacken
    end
  end
  
  LETTERS = %w(A B C D E F G H I J K L M N O P Q R S)
  
  SGF_BLACK_PLACEMENT_PROPERTIES = %w(B AB)
  SGF_WHITE_PLACEMENT_PROPERTIES = %w(W AW)
  
  def valid_position?(str)
    !!parse_position(str)
  end
  
  TEMPLATES = DIMENSIONS.inject(Hash.new) do |templates, dim|
    templates.merge(
      dim => returning((1..dim).map{ [:blank] * dim }) do |arr|
        (1..(dim-2)).each do |num|
          arr[0][num] = :left
          arr[num][0] = :top
          arr[num][-1] = :bottom
          arr[-1][num] = :right
        end
        arr[0][0] = :topleft
        arr[0][-1] = :bottomleft
        arr[-1][0] = :topright
        arr[-1][-1] = :bottomright
        STARS[dim][HOSHI[dim]].each do |across, down|
          arr[across][down] = :star
        end
      end
    )
  end
  
  def map_array(map)
    arr = self.to_a
    template = TEMPLATES[self.dimension]
    (0..(self.dimension - 1)).map do |across|
      (0..(self.dimension - 1)).map do |down|
        map[template[across][down]][arr[across][down]] # or puts "template[across][down] -> #{template[across][down]}, map[template[across][down]] -> #{map[template[across][down]]}"
      end
    end
  end
  
  # options:
  #
  # board[0][0] => Location
  # board['aa'] => Location
  # board[:id]  => ActiveRecord default behaviour
  def [](str_or_symbol_or_offset)
    if str_or_symbol_or_offset.kind_of?(Integer)
      return Column.new(self, str_or_symbol_or_offset)
    else
      str = str_or_symbol_or_offset.to_s.downcase
      if valid_position?(str)
        return parse_position(str)
      else
        super(str_or_symbol_or_offset)
      end
    end
  end
  
  def []=(str_or_symbol,value)
    # TODO: memoize #to_a and invalidate it here
    initialize_as_str
    str = str_or_symbol.to_s.downcase
    if valid_position?(str)
      arr = self.to_a
      loc = parse_position(str)
      if value.nil?
        loc.remove
      else
        loc.have(value)
      end
      loc
    else
      super(str_or_symbol)
    end
  end
  
  def to_a
    initialize_as_str
    eval(self.as_str)
  end
  
  def groupings
    black_offsets, white_offsets = self.stone_locations
    BlacksAndWhites.for(
      Grouping.groupings_for_one_colour(self, black_offsets),
      Grouping.groupings_for_one_colour(self, white_offsets)
    )
  end
  
  def dead_groupings
    self.groupings.map { |groupings_of_one_colour|
      groupings_of_one_colour.select { its.dead? }
    }
  end
  
  def dead_stones
    self.dead_groupings.map { it.inject([], &:+) }
  end
  
  def stone_locations
    #shlemiel the painter goes to work
    returning(BlacksAndWhites.for([], [])) do |blacks, whites|
      (0..(self.dimension - 1)).each do |across|
        (0..(self.dimension - 1)).each do |down|
          if self.to_a[across][down] == BLACK_S
            blacks << Location.for(self, across, down)
          elsif self.to_a[across][down] == WHITE_S
            whites << Location.for(self, across, down)
          end
        end
      end
    end
  end
  
  def parse_position(str)
    offsets = str.scan(/[abcdefghijklmnopqrst]/i).map { LETTERS.index(its.upcase) }.select { it && it >= 0 && it < dimension  }
    Location.for(self, offsets.first, offsets.last) if offsets.size == 2
  end
  
  def initialize_as_str
    if self.as_str.blank?
      self.as_str = ((1..self.dimension).map{ [nil] * self.dimension }).inspect
    end
  end
  
end