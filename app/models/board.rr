require 'ostruct'

class Board
  
  attr_reader :stones_array
  attr_accessor :dimension
  
  DIMENSIONS = [9, 11, 13, 15, 17, 19]
  
  BLACK_S, WHITE_S = 'black', 'white'
  
  LETTERS = %w(A B C D E F G H I J K L M N O P Q R S)
      
  def self.position_to_location(str)
    str.scan(/[abcdefghijklmnopqrst]/i).map { |l| Board::LETTERS.index(l.upcase) }.select { |i| i && i >= 0 && i < 18  }
  end
  
  def self.location_to_position(arr)
    "#{Board::LETTERS[arr[0]]}#{Board::LETTERS[arr[1]]}".downcase
  end
  
  class Occupied < Exception; end
  
  class Wtf < Exception; end
  
  class Placement
    
    attr_reader :across, :down
    
    def initialize(across_or_position, down = nil)
      if across_or_position.kind_of?(Integer) && down.kind_of?(Integer)
        @across, @down = across_or_position, down
      elsif down.nil?
        @across, @down = across_or_position.scan(/[abcdefghijklmnopqrst]/i).map { Board::LETTERS.index(its.upcase) }
      end
    end
    
  end
  
  class Black < Placement
    
    def colour
      'black'
    end
    
  end
  
  class White < Placement
    
    def colour
      'white'
    end
    
  end
  
  # intended for an array of two elements, one of which is an array of black things
  # and the other is an array of white things
  module BlacksAndWhites
    
    def self.for(*arr)
      returning(arr) do
        arr.extend(self)
      end
    end
    
    def blacks
      self.first
    end
    
    def whites
      self.last
    end
    
    def all
      self.first + self.last
    end
    
    def map
      BlacksAndWhites.for(yield(blacks), yield(whites))
    end
    
  end
  
  # intended to extend an array of two offsets across and down
  module Location
    
    attr_accessor :board
    
    def self.for(board, across, down)
      returning([across, down]) do
        it.extend(self)
        it.board = board
      end
    end
    
    def across
      self.first
    end
    
    def down
      self.last
    end
    
    def open?
      self.board.stones_array[self.across][self.down].blank?
    end
    
    def black?
      self.has?(BLACK_S)
    end
    
    def white?
      self.has?(WHITE_S)
    end
    
    def has?(colour)
      self.board.stones_array[self.across][self.down] == colour
    end
    
    def have(colour)
      self.board.stones_array[self.across][self.down] = colour
      self
    end
    
    def blacken
      self.have(BLACK_S)
    end
    
    def whiten
      self.have(WHITE_S)
    end
    
    def remove
      self.board.stones_array[self.across][self.down] = nil
      self
    end
  
    def adjacent_scalars(offset)
      if offset == 0
        [offset + 1]
      elsif offset == (board.dimension - 1)
        [offset - 1]
      else
        [offset + 1, offset - 1]
      end
    end
  
    def adjacent_locations
      self.adjacent_scalars(self.across).map { Location.for(board, it, self.down) } + 
      self.adjacent_scalars(self.down).map { Location.for(board, self.across, it) }
    end
  
    def liberties
      self.adjacent_locations.select{ its.open? }
    end
    
    def has_liberty?
      !self.liberties.empty?
    end
    
    def left_edge?
      self.across == 0
    end
    
    def right_edge?
      self.across == (self.board.dimension - 1)
    end
    
    def center?
      !self.left_edge? && !self.right_edge?
    end
    
    def top_edge?
      self.down == 0
    end
    
    def bottom_edge?
      self.down == (self.board.dimension - 1)
    end
    
    def middle?
      !self.top_edge? && !self.bottom_edge?
    end
    
    def hoshi?
      self.board.hoshi_points.include?(self)
    end
    
    def to_s
      (LETTERS[self.across] + LETTERS[self.down]).downcase
    end
    
    def to_a
      [self.across, self.down]
    end
    
  end

  # intended to extend arrays of locations
  module Grouping
  
    # def valid?
    #   black_groupings, white_groupings = self.class.groupings(@board, @offsets)
    #   both_groupings = black_groupings + white_groupings
    #   both_groupings.size == 1 && both_groupings.first.size == @offsets.size
    # end
    
    attr_accessor :board
    
    def self.for(board, *locations)
      returning(locations) do
        it.extend(self)
        it.board = board
      end
    end
    
    def self.groupings_for_one_colour(board, stones)
      stones.inject([]) do |groupings_so_far, stone|
        raise "I screwed this up" unless stone.kind_of?(Location)
        groupings_adjacent_to_this_stone = stone.adjacent_locations.map { |adjacent_location|
          groupings_so_far.detect { it.include?(adjacent_location) }
        }.compact
        if groupings_adjacent_to_this_stone.size == 0
          # create a new grouping
          groupings_so_far << self.for( board, stone )
        elsif groupings_adjacent_to_this_stone.size == 1
          # add this stone to the grouping
          groupings_adjacent_to_this_stone.first << stone 
        else
          # merge groupings
          groupings_so_far = groupings_so_far - 
              groupings_adjacent_to_this_stone + 
              [
                self.for(
                  board,
                  *(groupings_adjacent_to_this_stone.inject(&:+) + [stone])
                )
              ]
        end
        groupings_so_far
      end
    end
    
    def liberties
      self.map { its.liberties }.inject([], &:+)
    end
    
    def alive?
      self.any? { it.has_liberty? } 
    end
    
    def dead?
      !self.alive?
    end
  
  end
  
  class Column
    
    attr_accessor :board
    attr_accessor :across
    
    def initialize(board, across)
      self.board = board
      self.across = across
    end
    
    def [](down)
      Location.for(board, self.across, down)
    end
    
    def []=(down, value)
      returning(Location.for(board, self.across, down)) do |location|
        if value.nil?
          location.remove
        elsif value == WHITE_S || value == BLACK_S
          location.have(value)
        else
          raise Wtf.new("WTF is a #{value.inspect}?")
        end
      end
    end
      
    
  end
  
  def self.validate_for(belongs_to, *board_attrs)
    board_attrs.each do |sym|
      board = belongs_to.send(sym)
      board.invalid_reasons.each do |reason|
        belongs_to.errors.add(sym, reason)
      end
    end
  end
      
  state_machine(:state, :initial => :writable) do ||
    
    event :lock do ||
      transition :writable => :readable
    end
    
    after_transition any => :readable do |board, transition|
      board.stones_array.freeze
      board.stones_array.each(&:freeze)
    end
    
    state :writable do ||
      
      def as_str=(str)
        @stones_array = eval(str)
      end
      
      def stones_array=(arr)
        @stones_array = arr
      end
  
      def []=(str_or_symbol, value)
        str = str_or_symbol.to_s.downcase
        if valid_position?(str)
          loc = parse_position(str)
          if value.nil?
            loc.remove
          else
            loc.have(value)
          end
          loc
        else
          super(str_or_symbol, value)
        end
      end
  
      def handicap(number_of_stones)
        self.star_points(number_of_stones).each do |across, down|
          self[across][down].blacken
        end
      end
  
    end
    
    state :readable do ||
  
      def invalid_reasons
        returning([]) do |reasons|
          undead = self.dead_stones.all
          reasons << "The stones at #{undead.to_sentence} are dead"unless undead.empty?
          # reasons << "#{self.dimension} is not a valid board size" unless DIMENSIONS.include?(self.dimension)
        end
      end
  
      def valid?
        self.invalid_reasons.empty?
      end
  
      def map_array(map)
        template = TEMPLATES[self.dimension]
        (0..(self.dimension - 1)).map do |across|
          (0..(self.dimension - 1)).map do |down|
            map[template[across][down]][self.stones_array[across][down]] # or puts "template[across][down] -> #{template[across][down]}, map[template[across][down]] -> #{map[template[across][down]]}"
          end
        end
      end
  
      def + something
        if something.respond_to?(:across) && something.respond_to?(:down) && something.respond_to?(:colour)
          self + [something]
        else
          Board.new(self.dimension, self.as_str) do |other|
            something.each { other[its.across][its.down] = its.colour unless its.colour.nil? }
          end
        end
      end
  
      def - something
        if something.respond_to?(:across) && something.respond_to?(:down)
          self - [something]
        else
          Board.new(self.dimension, self.as_str) do |other|
            something.each { other[its.across][its.down].remove }
          end
        end
      end
      
      #---------- OLD SCHOOL ----------
 
      def groupings
        black_offsets, white_offsets = self.stone_locations
        BlacksAndWhites.for(
          Grouping.groupings_for_one_colour(self, black_offsets),
          Grouping.groupings_for_one_colour(self, white_offsets)
        )
      end
  
      def dead_groupings
        self.groupings.map { |groupings_of_one_colour|
          groupings_of_one_colour.select { its.dead? }
        }
      end
  
      def dead_stones
        self.dead_groupings.map { it.inject([], &:+) }
      end
  
      def empty_locations
        returning([]) do |empties|
          (0..(self.dimension - 1)).each do |across|
            (0..(self.dimension - 1)).each do |down|
              empties << Location.for(self, across, down) if self.stones_array[across][down].nil?
            end
          end
        end
      end
  
      def stone_locations
        #shlemiel the painter goes to work
        returning(BlacksAndWhites.for([], [])) do |blacks, whites|
          (0..(self.dimension - 1)).each do |across|
            (0..(self.dimension - 1)).each do |down|
              if self.stones_array[across][down] == BLACK_S
                blacks << Location.for(self, across, down)
              elsif self.stones_array[across][down] == WHITE_S
                whites << Location.for(self, across, down)
              end
            end
          end
        end
      end
      
      
      #---------- NEW SCHOOL ----------
  
      def info(debug = false)
        aa = self.adjacents_array
        returning(OpenStruct.new(
          :belong_to_group => dim_by_dim_array(), 
          :group_liberties_by_location => dim_by_dim_array(), 
          :empty_place_liberties => [],
          :group_liberties => [[], []]
        )) do |rval|
          (0..(self.dimension - 1)).each do |across|
            (0..(self.dimension - 1)).each do |down|
              colour = stones_array[across][down]
              if colour.blank?
                rval.empty_place_liberties << [across, down] if aa[across][down].any? { |a_adj, d_adj| stones_array[a_adj][d_adj].blank? }
              else
                # by default, it is its own group
                rval.belong_to_group[across][down] = [across, down]
                rval.group_liberties_by_location[across][down] = []
                aa[across][down].each do |a_adj, d_adj|
                  adj_colour = stones_array[a_adj][d_adj]
                  if adj_colour.blank?
                    rval.group_liberties_by_location[rval.belong_to_group[across][down][0]][rval.belong_to_group[across][down][1]].into do |lib_arr|
                      lib_arr << [a_adj, d_adj]
                      lib_arr.uniq!
                    end
                  elsif adj_colour == colour && (a_adj < across or a_adj == across && d_adj < down)
                    # merge groups
                    adj_bt = rval.belong_to_group[a_adj][d_adj]
                    this_bt = rval.belong_to_group[across][down]
                    if adj_bt != this_bt # merge groups
                      puts "merging this_bt: #{this_bt.inspect} with adj_bt: #{adj_bt.inspect}" if debug
                      case adj_bt <=> this_bt
                      when -1:
                        from, to = this_bt, adj_bt
                      when 1:
                        from, to = adj_bt, this_bt
                      when 0:
                        raise "unexpected error in Board#info"
                      end
                      # copy liberties and nil out
                      rval.group_liberties_by_location[to[0]][to[1]] += rval.group_liberties_by_location[from[0]][from[1]]
                      rval.group_liberties_by_location[from[0]][from[1]] = nil
                      rval.group_liberties_by_location[to[0]][to[1]].uniq!
                      # update all belongs_to
                      (to[0]..across).each do |i_across|
                        if i_across == to[0]
                          low_down = to[1]
                        else
                          low_down = 0
                        end
                        if i_across == from[0]
                          high_down = from[1]
                        else
                          high_down = self.dimension - 1
                        end
                        (low_down..high_down).each do |i_down|
                          if rval.belong_to_group[i_across][i_down] == from
                            puts "changing belongs_to of #{rval.belong_to_group[i_across][i_down]} to #{to}" if debug
                            rval.belong_to_group[i_across][i_down] = to
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
          if debug
            messages = []
            (0..(self.dimension - 1)).each do |across|
              (0..(self.dimension - 1)).each do |down|
                #messages << "rval.belong_to_group[#{across}][#{down}]: #{rval.belong_to_group[across][down].inspect}"
                messages << "rval.group_liberties_by_location[#{across}][#{down}]: #{rval.group_liberties_by_location[across][down].inspect}"  
              end
            end
            puts messages.join(', ')
          end
          #---------- Second pass to consolidate certain derivatives.   ----------
          #---------- Optimize into the first pass when the api settles ----------
          group_locations_to_liberties_and_stones = {}
          (0..(self.dimension - 1)).each do |across|
            (0..(self.dimension - 1)).each do |down|
              unless rval.group_liberties_by_location[across][down].blank?
                # rval.group_liberties[self.stones_array[across][down] == Board::BLACK_S ? 0 : 1] << rval.group_liberties_by_location[across][down]
                group_locations_to_liberties_and_stones[[across, down]] ||= OpenStruct.new(
                  :liberties => rval.group_liberties_by_location[across][down],
                  :stones => []
                )
                puts "group_locations_to_liberties_and_stones[#{[across, down].inspect}]: #{group_locations_to_liberties_and_stones[[across, down]].inspect}" if debug
              end
              unless rval.belong_to_group[across][down].blank?
                puts "group_locations_to_liberties_and_stones[#{rval.belong_to_group[across][down].inspect}]: ???" if debug
                group_locations_to_liberties_and_stones[rval.belong_to_group[across][down]].stones << [across, down]
              end
            end
          end
          rval.group_liberties = group_locations_to_liberties_and_stones.inject([[], []]) do |acc, val|
            returning(acc) do |blacks_and_whites|
              location, liberties_and_stones = *val
              across, down = *location
              blacks_and_whites[self.stones_array[across][down] == Board::BLACK_S ? 0 : 1] << liberties_and_stones
            end
          end
        end
      end
  
      def legal_moves_for(player)
        if player == BLACK_S
          player_i, opponent_i, opponent = 0, 1, WHITE_S
        else
          player_i, opponent_i, opponent = 1, 0, BLACK_S
        end
        
        # any empty spot with one or more liberties is a legal move
        empty_placements_with_liberty = self.info.empty_place_liberties.map { 
          OpenStruct.new(:location => it, :dead_stones => []) 
        }
        
        # any liberty belonging to a group with two or more liberties is a legal spot
        placements_that_grow_player_groups = self.info.group_liberties[player_i].select{ |liberties_and_stones|
          liberties_and_stones.liberties.size > 1 
        }.map{ |liberties_and_stones|
          liberties_and_stones.liberties.map { OpenStruct.new(:location => it, :dead_stones => []) }
        }.inject([], &:+)
        
        # any spot that performs a capture is a legal spot
        placements_that_capture = self.info.group_liberties[opponent_i].select { |liberties_and_stones|
          liberties_and_stones.liberties.size == 1 
        }.map {
          OpenStruct.new(:location => its.liberties.first, :dead_stones => its.stones)
        }
        
        (empty_placements_with_liberty + placements_that_grow_player_groups + placements_that_capture).inject({}) do |legal_move_hash, location_and_dead_stones|
          returning(legal_move_hash) do |h|
            h[location_and_dead_stones.location] ||= []
            h[location_and_dead_stones.location] += location_and_dead_stones.dead_stones
          end
        end.map do |location, dead_stones|
          OpenStruct.new(:location => location, :dead_stones => dead_stones)
        end
      end
      
      #---------- quasi-private ----------
  
      def adjacent_scalars_lambda
        lambda do |magnitude|
          if magnitude == 0
            return [magnitude + 1]
          elsif magnitude == (self.dimension - 1)
            return [magnitude - 1]
          else
            return [magnitude - 1, magnitude + 1]
          end
        end
      end
  
      def adjacents_priors_helper(scalar_lambda)
        returning((1..self.dimension).map{(1..self.dimension).map{Array.new}}) do |a|
          (0..(self.dimension - 1)).each do |across|
            a_adj = scalar_lambda[across]
            (0..(self.dimension - 1)).each do |down|
              d_adj = scalar_lambda[down]
              a_adj.each do |a_e|
                a[across][down] << [a_e, down]
              end
              d_adj.each do |d_e|
                a[across][down] << [across, d_e]
              end
            end
          end
        end
      end
  
      def adjacents_array
        @@adjacents_array ||= {}
        @@adjacents_array[self.dimension] ||= adjacents_priors_helper(self.adjacent_scalars_lambda)
      end
  
    end
    
  end
  
  def initialize(dimension_or_board, str = nil)
    super()
    if dimension_or_board.kind_of?(Fixnum)
      self.dimension = dimension_or_board 
      self.as_str = str unless str.blank?
      self.stones_array ||= self.dim_by_dim_array()
    elsif dimension_or_board.kind_of?(Board)
      self.dimension = dimension_or_board.dimension
      self.stones_array = dimension_or_board.stones_array.map { it.map { it } }
    end
    yield self if block_given?
    self.lock
    self
  end
  
  def as_str
    self.stones_array.inspect
  end
  
  STARS = Board::DIMENSIONS.inject(Hash.new) do |sizes_to_game_sets, dimension|
    sizes_to_game_sets.merge(
      dimension => begin
        offset = if dimension <= 11
            3
          else
            4
          end
        top = left = offset - 1
        middle = dimension / 2
        bottom = right = dimension - offset
        {
          2 => [[left, bottom], [right, top]],
          3 => [[left, bottom], [right, top], [right, bottom]],
          4 => [[left, bottom], [right, top], [right, bottom], [left, top]],
          5 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [middle, middle]],
          6 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [left, middle], [right, middle]],
          7 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [left, middle], [right, middle], [middle, middle]],
          8 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [left, middle], [right, middle], [middle, top], [middle, bottom]],
          9 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [left, middle], [right, middle], [middle, top], [middle, bottom],
                [middle, middle]]
        }
      end
    )
  end
  
  HOSHI = Board::DIMENSIONS.inject(Hash.new) do |board_size_to_number_of_hoshi, dimension|
    board_size_to_number_of_hoshi.merge(
      if dimension < 13
        {dimension => 4}
      elsif dimension < 17
        {dimension => 5}
      else
        {dimension => 9}
      end
    ) 
  end
  
  def star_points(number_of_stones)
    STARS[self.dimension][number_of_stones]
  end
  
  def hoshi_points()
    @hoshi_points ||= self.star_points(HOSHI[self.dimension])
  end
  
  SGF_BLACK_PLACEMENT_PROPERTIES = %w(B AB)
  SGF_WHITE_PLACEMENT_PROPERTIES = %w(W AW)
  
  def valid_position?(str)
    !!parse_position(str)
  end
  
  TEMPLATES = DIMENSIONS.inject(Hash.new) do |templates, dim|
    templates.merge(
      dim => returning((1..dim).map{ [:blank] * dim }) do |arr|
        (1..(dim-2)).each do |num|
          arr[0][num] = :left
          arr[num][0] = :top
          arr[num][-1] = :bottom
          arr[-1][num] = :right
        end
        arr[0][0] = :topleft
        arr[0][-1] = :bottomleft
        arr[-1][0] = :topright
        arr[-1][-1] = :bottomright
        STARS[dim][HOSHI[dim]].each do |across, down|
          arr[across][down] = :star
        end
      end
    )
  end
  
  # options:
  #
  # board[0][0] => Location
  # board['aa'] => Location
  def [](str_or_symbol_or_offset)
    if str_or_symbol_or_offset.kind_of?(Integer)
      return Column.new(self, str_or_symbol_or_offset)
    else
      str = str_or_symbol_or_offset.to_s.downcase
      if valid_position?(str)
        return parse_position(str)
      else
        super(str_or_symbol_or_offset)
      end
    end
  end
  
  def to_a
    self.stones_array
  end
  
  protected
  
  def dim_by_dim_array
    ((1..self.dimension).map{ [nil] * self.dimension })
  end
  
  def parse_position(str)
    offsets = str.scan(/[abcdefghijklmnopqrst]/i).map { LETTERS.index(its.upcase) }.select { it && it >= 0 && it < self.dimension  }
    Location.for(self, offsets.first, offsets.last) if offsets.size == 2
  end
  
end