class Board < ActiveRecord::Base
  
  class Occupied < Exception; end
  
  class Wtf < Exception; end
  
  # intended to extend an array of two offsets across and down
  module Location
    
    attr_accessor :board
    
    def self.for(board, across, down)
      returning([across, down]) do
        it.extend(self)
        it.board = board
      end
    end
    
    def across
      self.first
    end
    
    def down
      self.last
    end
    
    def open?
      self.board.to_a[self.across][self.down].blank?
    end
    
    def black?
      self.has?('black')
    end
    
    def white?
      self.has?('white')
    end
    
    def has?(colour)
      self.board.to_a[self.across][self.down] == colour.to_s.downcase
    end
    
    def have(colour)
      self.board[LETTERS[self.across] + LETTERS[self.down]] = colour
    end
    
    def remove
      self.board[LETTERS[self.across] + LETTERS[self.down]] = nil
    end
  
    def adjacent_scalars(offset)
      if offset == 0
        [offset + 1]
      elsif offset == (board.dimension - 1)
        [offset - 1]
      else
        [offset + 1, offset - 1]
      end
    end
  
    def adjacent_locations
      self.adjacent_scalars(self.across).map { Location.for(board, it, self.down) } + 
      self.adjacent_scalars(self.down).map { Location.for(board, self.across, it) }
    end
  
    def liberties
      self.adjacent_locations.select{ its.open? }
    end
    
    def has_liberty?
      !self.liberties.empty?
    end
    
  end

  # intended to extend arrays of locations
  module Grouping
  
    # def valid?
    #   black_groupings, white_groupings = self.class.groupings(@board, @offsets)
    #   both_groupings = black_groupings + white_groupings
    #   both_groupings.size == 1 && both_groupings.first.size == @offsets.size
    # end
    
    attr_accessor :board
    
    def self.for(board, *locations)
      returning(locations) do
        it.extend(self)
        it.board = board
      end
    end
    
    def self.groupings_for_one_colour(board, stones)
      stones.inject([]) do |groupings_so_far, stone|
        raise "I screwed this up" unless stone.kind_of?(Location)
        groupings_adjacent_to_this_stone = stone.adjacent_locations.map { |adjacent_location|
          groupings_so_far.detect { it.include?(adjacent_location) }
        }.compact
        if groupings_adjacent_to_this_stone.size == 0
          # create a new grouping
          groupings_so_far << self.for( board, stone )
        elsif groupings_adjacent_to_this_stone.size == 1
          # add this stone to the grouping
          groupings_adjacent_to_this_stone.first << stone 
        else
          # merge groupings
          groupings_so_far = groupings_so_far - 
              groupings_adjacent_to_this_stone + 
              [
                self.for(
                  board,
                  *(groupings_adjacent_to_this_stone.inject(&:+) + [stone])
                )
              ]
        end
        groupings_so_far
      end
    end
    
    def liberties
      self.map { its.liberties }.inject([], &:+)
    end
    
    def alive?
      self.any? { it.has_liberty? } 
    end
    
    def dead?
      !self.alive?
    end
  
  end
  
  class Column
    
    attr_accessor :board
    attr_accessor :across
    
    def initialize(board, across)
      self.board = board
      self.across = across
    end
    
    def [](down)
      Location.for(board, self.across, down)
    end
    
    def []=(down, value)
      returning(Location.for(board, self.across, down)) do |location|
        if value.nil?
          location.remove
        elsif value == 'white' || value == 'black'
          location.have(value)
        else
          raise Wtf.new("WTF is a #{value.inspect}?")
        end
      end
    end
      
    
  end
  
  before_validation_on_create :initialize_sgf_hack
  
  validates_inclusion_of :dimension, :in => [9, 11, 13, 15, 17, 19]
  
  def self.initial(options = {})
    #TODO: fork everything from common starts
    self.create(options)
  end
  
  LETTERS = %w(A B C D E F G H I J K L M N O P Q R S)
  
  SGF_BLACK_PLACEMENT_PROPERTIES = %w(B AB)
  SGF_WHITE_PLACEMENT_PROPERTIES = %w(W AW)
  
  def valid_position?(str)
    !!parse_position(str)
  end
  
  # options:
  #
  # board[0][0] => Location
  # board['aa'] => Location
  # board[:id]  => ActiveRecord default behaviour
  def [](str_or_symbol_or_offset)
    if str_or_symbol_or_offset.kind_of?(Integer)
      return Column.new(self, str_or_symbol_or_offset)
    else
      str = str_or_symbol_or_offset.to_s.downcase
      if valid_position?(str)
        return parse_position(str)
      else
        super(str_or_symbol_or_offset)
      end
    end
  end
  
  def []=(str_or_symbol,value)
    # TODO: memoize #to_a and invalidate it here
    str = str_or_symbol.to_s.downcase
    if valid_position?(str)
      self.sgf_hack = self.sgf_hack.gsub(";B[#{str}]", '').gsub(";W[#{str}]", '')
      self.sgf_hack = self.sgf_hack + if value == 'black'
        ";B[#{str}]"
      elsif value == 'white'
        ";W[#{str}]"
      elsif value.nil?
        ''
      else
        raise Wtf.new("What is a #{value}?")
      end
    else
      super(str_or_symbol)
    end
  end
  
  def to_a
    # TODO: memoize and invalidate []=
    returning( (1..self.dimension).map{[nil] * self.dimension} ) do |arr|
      ['black', 'white'].zip(self.stone_locations).each { |colour, list_of_offsets|  
        list_of_offsets.each { |across, down| 
          arr[across][down] = colour 
        }
      }
    end
  end
  
  def groupings
    black_offsets, white_offsets = self.stone_locations
    [
      Grouping.groupings_for_one_colour(self, black_offsets),
      Grouping.groupings_for_one_colour(self, white_offsets)
    ]
  end
  
  def dead_groupings
    self.groupings.map { |groupings_of_one_colour|
      groupings_of_one_colour.select { its.dead? }
    }
  end
  
  def dead_stones
    self.dead_groupings.map { it.inject([], &:+) }
  end
  
  def stone_locations
    returning([[], []]) do |blacks, whites|
      self.sgf_hack.scan(/([BW])\[([abcdefghijklmnopqrs][abcdefghijklmnopqrs])\]/) do |initial, position|
        if initial == 'B'
          blacks << parse_position(position)
        else
          whites << parse_position(position)
        end
      end
    end
  end
  
  def parse_position(str)
    offsets = str.scan(/[abcdefghijklmnopqrst]/i).map { LETTERS.index(its.upcase) }.select { it && it >= 0 && it < dimension  }
    Location.for(self, offsets.first, offsets.last) if offsets.size == 2
  end
  
  def initialize_sgf_hack
    self.sgf_hack ||= ((1..self.dimension).map{ [nil] * self.dimension }).inspect
  end
  
end