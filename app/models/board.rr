class Board < ActiveRecord::Base
  
  DIMENSIONS = [9, 11, 13, 15, 17, 19]
  
  class Occupied < Exception; end
  
  class Wtf < Exception; end
  
  # intended for an array of two elements, one of which is an array of black things
  # and the other is an array of white things
  module BlacksAndWhites
    
    def self.for(*arr)
      returning(arr) do
        arr.extend(self)
      end
    end
    
    def blacks
      self.first
    end
    
    def whites
      self.last
    end
    
    def all
      self.first + self.last
    end
    
    def map
      BlacksAndWhites.for(yield(blacks), yield(whites))
    end
    
  end
  
  # intended to extend an array of two offsets across and down
  module Location
    
    attr_accessor :board
    
    def self.for(board, across, down)
      returning([across, down]) do
        it.extend(self)
        it.board = board
      end
    end
    
    def across
      self.first
    end
    
    def down
      self.last
    end
    
    def open?
      self.board.to_a[self.across][self.down].blank?
    end
    
    def black?
      self.has?('black')
    end
    
    def white?
      self.has?('white')
    end
    
    def has?(colour)
      self.board.to_a[self.across][self.down] == colour
    end
    
    def have(colour)
      arr = self.board.to_a
      arr[self.across][self.down] = colour
      self.board.array_hack = arr.inspect
      self
    end
    
    def blacken
      self.have('black')
    end
    
    def whiten
      self.have('white')
    end
    
    def remove
      arr = self.board.to_a
      arr[self.across][self.down] = nil
      self.board.array_hack = arr.inspect
      self
    end
  
    def adjacent_scalars(offset)
      if offset == 0
        [offset + 1]
      elsif offset == (board.dimension - 1)
        [offset - 1]
      else
        [offset + 1, offset - 1]
      end
    end
  
    def adjacent_locations
      self.adjacent_scalars(self.across).map { Location.for(board, it, self.down) } + 
      self.adjacent_scalars(self.down).map { Location.for(board, self.across, it) }
    end
  
    def liberties
      self.adjacent_locations.select{ its.open? }
    end
    
    def has_liberty?
      !self.liberties.empty?
    end
    
    def to_s
      (LETTERS[self.across] + LETTERS[self.down]).downcase
    end
    
  end

  # intended to extend arrays of locations
  module Grouping
  
    # def valid?
    #   black_groupings, white_groupings = self.class.groupings(@board, @offsets)
    #   both_groupings = black_groupings + white_groupings
    #   both_groupings.size == 1 && both_groupings.first.size == @offsets.size
    # end
    
    attr_accessor :board
    
    def self.for(board, *locations)
      returning(locations) do
        it.extend(self)
        it.board = board
      end
    end
    
    def self.groupings_for_one_colour(board, stones)
      stones.inject([]) do |groupings_so_far, stone|
        raise "I screwed this up" unless stone.kind_of?(Location)
        groupings_adjacent_to_this_stone = stone.adjacent_locations.map { |adjacent_location|
          groupings_so_far.detect { it.include?(adjacent_location) }
        }.compact
        if groupings_adjacent_to_this_stone.size == 0
          # create a new grouping
          groupings_so_far << self.for( board, stone )
        elsif groupings_adjacent_to_this_stone.size == 1
          # add this stone to the grouping
          groupings_adjacent_to_this_stone.first << stone 
        else
          # merge groupings
          groupings_so_far = groupings_so_far - 
              groupings_adjacent_to_this_stone + 
              [
                self.for(
                  board,
                  *(groupings_adjacent_to_this_stone.inject(&:+) + [stone])
                )
              ]
        end
        groupings_so_far
      end
    end
    
    def liberties
      self.map { its.liberties }.inject([], &:+)
    end
    
    def alive?
      self.any? { it.has_liberty? } 
    end
    
    def dead?
      !self.alive?
    end
  
  end
  
  class Column
    
    attr_accessor :board
    attr_accessor :across
    
    def initialize(board, across)
      self.board = board
      self.across = across
    end
    
    def [](down)
      Location.for(board, self.across, down)
    end
    
    def []=(down, value)
      returning(Location.for(board, self.across, down)) do |location|
        if value.nil?
          location.remove
        elsif value == 'white' || value == 'black'
          location.have(value)
        else
          raise Wtf.new("WTF is a #{value.inspect}?")
        end
      end
    end
      
    
  end
  
  before_validation_on_create :initialize_array_hack
  
  validates_inclusion_of :dimension, :in => DIMENSIONS
  
  validate do |board|
    undead = board.dead_stones.all
    board.errors.add_to_base("The stones at #{undead.to_sentence} are dead") unless undead.empty?
  end
  
  STARS = Board::DIMENSIONS.inject(Hash.new) do |sizes_to_game_sets, dimension|
    sizes_to_game_sets.merge(
      dimension => begin
        offset = if dimension <= 11
            3
          else
            4
          end
        top = left = offset - 1
        middle = dimension / 2
        bottom = right = dimension - offset
        {
          2 => [[left, bottom], [right, top]],
          3 => [[left, bottom], [right, top], [right, bottom]],
          4 => [[left, bottom], [right, top], [right, bottom], [left, top]],
          5 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [middle, middle]],
          6 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [left, middle], [right, middle]],
          7 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [left, middle], [right, middle], [middle, middle]],
          8 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [left, middle], [right, middle], [middle, top], [middle, bottom]],
          9 => [[left, bottom], [right, top], [right, bottom], [left, top], 
                [left, middle], [right, middle], [middle, top], [middle, bottom],
                [middle, middle]]
        }
      end
    )
  end
  
  def star_points(number_of_stones)
    STARS[self.dimension][number_of_stones]
  end
  
  def handicap(number_of_stones)
    self.star_points(number_of_stones).each do |across, down|
      self[across][down].blacken
    end
  end
  
  LETTERS = %w(A B C D E F G H I J K L M N O P Q R S)
  
  SGF_BLACK_PLACEMENT_PROPERTIES = %w(B AB)
  SGF_WHITE_PLACEMENT_PROPERTIES = %w(W AW)
  
  def valid_position?(str)
    !!parse_position(str)
  end
  
  # options:
  #
  # board[0][0] => Location
  # board['aa'] => Location
  # board[:id]  => ActiveRecord default behaviour
  def [](str_or_symbol_or_offset)
    if str_or_symbol_or_offset.kind_of?(Integer)
      return Column.new(self, str_or_symbol_or_offset)
    else
      str = str_or_symbol_or_offset.to_s.downcase
      if valid_position?(str)
        return parse_position(str)
      else
        super(str_or_symbol_or_offset)
      end
    end
  end
  
  def []=(str_or_symbol,value)
    # TODO: memoize #to_a and invalidate it here
    initialize_array_hack
    str = str_or_symbol.to_s.downcase
    if valid_position?(str)
      arr = self.to_a
      loc = parse_position(str)
      if value.nil?
        loc.remove
      else
        loc.have(value)
      end
      loc
    else
      super(str_or_symbol)
    end
  end
  
  def to_a
    initialize_array_hack
    eval(self.array_hack)
  end
  
  def groupings
    black_offsets, white_offsets = self.stone_locations
    BlacksAndWhites.for(
      Grouping.groupings_for_one_colour(self, black_offsets),
      Grouping.groupings_for_one_colour(self, white_offsets)
    )
  end
  
  def dead_groupings
    self.groupings.map { |groupings_of_one_colour|
      groupings_of_one_colour.select { its.dead? }
    }
  end
  
  def dead_stones
    self.dead_groupings.map { it.inject([], &:+) }
  end
  
  def stone_locations
    #shlemiel the painter goes to work
    returning(BlacksAndWhites.for([], [])) do |blacks, whites|
      (0..(self.dimension - 1)).each do |across|
        (0..(self.dimension - 1)).each do |down|
          if self.to_a[across][down] == 'black'
            blacks << Location.for(self, across, down)
          elsif self.to_a[across][down] == 'white'
            whites << Location.for(self, across, down)
          end
        end
      end
    end
  end
  
  def parse_position(str)
    offsets = str.scan(/[abcdefghijklmnopqrst]/i).map { LETTERS.index(its.upcase) }.select { it && it >= 0 && it < dimension  }
    Location.for(self, offsets.first, offsets.last) if offsets.size == 2
  end
  
  def initialize_array_hack
    if self.array_hack.blank?
      self.array_hack = ((1..self.dimension).map{ [nil] * self.dimension }).inspect
    end
  end
  
end