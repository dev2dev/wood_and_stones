class Board < ActiveRecord::Base
  
  class Occupied < Exception; end
  
  class Wtf < Exception; end
  
  # intended to extend an array of two offsets across and down
  module Location
    
    attr_accessor :board
    
    def self.for(board, across, down)
      returning([across, down]) do
        it.extend(self)
        it.board = board
      end
    end
    
    def across
      self.first
    end
    
    def down
      self.last
    end
    
    def open?
      self.board.to_a[self.across, self.down].blank?
    end
    
    def black?
      self.board.to_a[self.across, self.down] == 'black'
    end
    
    def white?
      self.board.to_a[self.across, self.down] == 'black'
    end
    
  end

  # intended to extend arrays of locations
  module Grouping
  
    # def valid?
    #   black_groupings, white_groupings = self.class.groupings(@board, @offsets)
    #   both_groupings = black_groupings + white_groupings
    #   both_groupings.size == 1 && both_groupings.first.size == @offsets.size
    # end
    
    attr_accessor :board
    
    def self.for(board, *locations)
      returning(locations) do
        it.extend(self)
        it.board = board
      end
    end
    
    def self.groupings_for_one_colour(board, offsets)
      offsets.inject([]) do |groupings_so_far, offset|
        across, down = offset
        groupings_adjacent_to_this_stone = board.stone_adjacents(across, down).map { |adjacent_across, adjacent_down|
          groupings_so_far.detect { it.include?([adjacent_across, adjacent_down]) }
        }.compact
        if groupings_adjacent_to_this_stone.size == 0
          # create a new grouping
          groupings_so_far << self.for( board, Location.for(board, across, down) )
        elsif groupings_adjacent_to_this_stone.size == 1
          # add this stone to the grouping
          groupings_adjacent_to_this_stone.first << [across, down] 
        else
          # merge groupings
          groupings_so_far = groupings_so_far - 
              groupings_adjacent_to_this_stone + 
              [
                self.for(
                  board,
                  groupings_adjacent_to_this_stone.inject(&:+) + [Location.for(board, across, down)]
                )
              ]
        end
        groupings_so_far
      end
    end
    
    def liberties
      self.inject([]) { |libs, offsets| libs + self.board.stone_liberties(*offsets) }
    end
    
    def alive?
      self.detect { !self.board.stone_liberties(*it).empty? } 
    end
    
    def dead?
      !self.alive?
    end
  
  end
  
  validates_inclusion_of :dimension, :in => [9, 11, 13, 15, 17, 19]
  
  before_create :initialize_sgf_hack
  
  def self.initial(options = {})
    #TODO: fork everything from common starts
    self.create(options)
  end
  
  LETTERS = %w(A B C D E F G H I J K L M N O P Q R S)
  
  SGF_BLACK_PLACEMENT_PROPERTIES = %w(B AB)
  SGF_WHITE_PLACEMENT_PROPERTIES = %w(W AW)
  
  def valid_position?(str)
    !!parse_position(str)
  end
  
  def [](str_or_symbol)
    str = str_or_symbol.to_s.downcase
    if valid_position?(str)
      SGF_BLACK_PLACEMENT_PROPERTIES.each { |property|
        return 'black' if self.sgf_hack.andand.index(";#{property}[#{str}]") || self.sgf_hack.andand.index("]#{property}[#{str}]")
      }
      SGF_WHITE_PLACEMENT_PROPERTIES.each { |property|
        return 'white' if self.sgf_hack.andand.index(";#{property}[#{str}]") || self.sgf_hack.andand.index("]#{property}[#{str}]")
      }
      return nil
    else
      super(str_or_symbol)
    end
  end
  
  def []=(str_or_symbol,value)
    # TODO: memoize #to_a and invalidate it here
    str = str_or_symbol.to_s.downcase
    if valid_position?(str)
      (SGF_BLACK_PLACEMENT_PROPERTIES + SGF_WHITE_PLACEMENT_PROPERTIES).each { |property|
        raise Occupied.new(str) if self.sgf_hack.andand.index(";#{property}[#{str}]") || self.sgf_hack.andand.index("]#{property}[#{str}]")
      }
      self.sgf_hack = (self.sgf_hack || '') + if value == 'black'
        ";B[#{str}]"
      elsif value == 'white'
        ";W[#{str}]"
      else
        raise Wtf.new("What is a #{value}?")
      end
    else
      super(str_or_symbol)
    end
  end
  
  def to_a
    # TODO: memoize and invalidate []=
    returning( (1..self.dimension).map{[nil] * self.dimension} ) do |arr|
      ['black', 'white'].zip(self.stone_offsets).each { |colour, list_of_offsets|  
        list_of_offsets.each { |across, down| 
          arr[across][down] = colour 
        }
      }
    end
  end
  
  def groupings
    black_offsets, white_offsets = self.stone_offsets
    [
      Grouping.groupings_for_one_colour(self, black_offsets),
      Grouping.groupings_for_one_colour(self, white_offsets)
    ]
  end
  
  def dead_groupings
    self.groupings.map { |groupings_of_one_colour|
      groupings_of_one_colour.select { its.dead? }
    }
  end
  
  def dead_stones
    self.dead_groupings.map { it.inject([], &:+) }
  end
  
  def stone_offsets
    returning([[], []]) do |blacks, whites|
      self.sgf_hack.scan(/([BW])\[([abcdefghijklmnopqrs][abcdefghijklmnopqrs])\]/) do |initial, position|
        if initial == 'B'
          blacks << parse_position(position)
        else
          whites << parse_position(position)
        end
      end
    end
  end
  
  def adjacent_scalars(offset)
    if offset == 0
      [offset + 1]
    elsif offset == (self.dimension - 1)
      [offset - 1]
    else
      [offset + 1, offset - 1]
    end
  end
  
  def stone_adjacents(across, down)
    adjacent_scalars(across).map { [it, down] } + adjacent_scalars(down).map { [across, it] }
  end
  
  def stone_liberties(across, down)
    stone_adjacents(across, down).select { |adjacent_across, adjacent_down| 
      self.to_a[adjacent_across][adjacent_down].blank? 
    }
  end
  
  def parse_position(str)
    offsets = str.scan(/[abcdefghijklmnopqrst]/i).map { LETTERS.index(its.upcase) }.select { it && it >= 0 && it < dimension  }
    [offsets.first, offsets.last] if offsets.size == 2
  end
  
  def initialize_sgf_hack
    self.sgf_hack ||= ''
  end
  
end